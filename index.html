<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Linux/x86 version 5.3.9">
  <meta charset="utf-8">
  <link href="webrtc.css" rel="stylesheet">
  <title>WebRTC Next Version Use Cases</title>
  <script class="remove" src="https://www.w3.org/Tools/respec/respec-w3c"></script>
  <script src="respec-config.js" class="remove"></script>
</head>
<body>
  <section id="abstract">
    <p>This document describes a set of use cases motivating the development of
    WebRTC Next Version (WebRTC-NV), as well as the requirements derived from
    those use cases.</p>
  </section>
  <section id="sotd"></section>
  <section id="overview*">
    <h2>Scope and Motivation</h2>
    <p>To motivate the development of WebRTC 1.0, the IETF RTCWEB WG developed [[?RFC7478]].
    This document describes use cases motivating the development of
    "WebRTC Next Version" (WebRTC-NV), and the requirements deriving from those use cases.
    The use cases fall into one of two categories:
    enhancements to use cases already covered in [[?RFC7478]], and
    new use cases which are not supported in WebRTC 1.0 [[?WEBRTC]] without extensions.</p>
   </section>
   <section id="existingusecases*">
    <h2>Existing Use Cases</h2>
      <p>The uses cases in this section improve upon use cases described in [[?RFC7478]].</p>
   <section id="multipartygame*">
      <h3>Multiparty online game with voice communications</h3>
      <p>[[?RFC7478]] Section 2.3.12 describes a use case involving a multiparty online game
        with voice communications. In these scenarios, reducing time to join the game and
        receive media is important. To minimize this, ICE enhancements are desirable, such as
        the ability to control candidate gathering and pruning.  Also, allowing a participant
        to broadcast a configuration to a “room” abstraction (maintained on a server), with
        other room participants responding back directly, avoiding a separate discovery step,
        minimizes conference establishment time. Also, managing audio quality and latency in
        a fair manner between multiple connections prevents queue buildup. Supporting this
        enhancement adds the following requirements:</p>
<table class="simple">
    <thead>
       <tr>
          <th>Requirement ID</th>
          <th>Description</th>
       </tr>
    </thead>
    <tbody>
        <tr>
           <td>N01</td>
           <td>The user agent can control candidate gathering
           and pruning, limiting the networks on which candidates
           are gathered, the types of candidates, etc.</td>
        </tr>
        <tr>
           <td>N02</td>
           <td>The user agent must be capable of establishing multiple
           connections to peers without generating a separate
           configuration ("offer") for each connection prior to
           establishment.</td>
        </tr>
        <tr>
           <td>N03</td>
           <td>Congestion control must be able to manage audio
           quality and latency in a fair manner between multiple
           connections.</td>
        </tr>
    </tbody>
</table>
     
<p>Experience: This use case has been implemented by a gaming service utilizing [[?ORTC]].</p>

References:
<ol>
  <li><a href="https://github.com/w3c/ortc/issues/54">ORTC Issue 54</a></li>
  <li><a href="https://github.com/w3c/ortc/issues/603">ORTC Issue 603</a></li>
</ol>
</section>
<section id="mobility*">
      <h3>Mobile calling service</h3>
      <p>[[?RFC7478]] Section 2.3.6 describes a simple communications service where the user changes access network
      during the session. This use case is enhanced by being able to ring multiple endpoints simultaneously, as
      well as to re-route media over an alternate path (potentially taking network cost into account) without need for signaling.</p> 
      <p>An additional enhancement is to provide management of the user experience at both ends of a call during interuptions
      to the media flow caused by other activities taking higher priority on the smartphone. </p>
<table class="simple">
    <thead>
       <tr>
          <th>Requirement ID</th>
          <th>Description</th>
       </tr>
    </thead>
    <tbody>
        <tr>
           <td>N02</td>
           <td>The user agent must be capable of establishing multiple
           connections to peers without generating a separate
           configuration ("offer") for each connection prior to
           establishment.</td>
        </tr>
        <tr>
           <td>N04</td>
           <td>The ICE agent must be able to maintain multiple
           candidate pairs and move traffic between them.</td>
        </tr>
        <tr>
           <td>N05</td>
           <td>The ICE agent must be able to take the network
           cost into account when considering re-routing.</td>
        </tr>
        <tr>
           <td>N30</td>
           <td>The user agent must provide the ability to re-establish media
           after an interruption.</td>
        </tr>
        <tr>
           <td>N31</td>
           <td>The user agent must provide notification of a media interruption
            caused by the OS (e.g. GSM incoming call) (c.f. on hold music).
            and support the use of a datachannel to inform the remote peer of the interruption.</td>
        </tr>
        <tr>
           <td>N32</td>
           <td>The user agent must provide the ability to 'park' a connection such
           that it can be retrieved and continued by a newly loaded page to prevent
           accidental 'browsing away' from dropping a call irretrievably.</td>
        </tr>
    </tbody>
</table>
<p>References:</p>
<ol>
  <li><a href="https://lists.w3.org/Archives/Public/public-webrtc/2018May/0079.html">Mailing list proposal</a></li>
  <li><a href="https://lists.w3.org/Archives/Public/public-webrtc/2018May/0019.html">Mailing list proposal</a></li>
  <li><a href="https://github.com/w3c/ortc/issues/583">ORTC Issue 583</a></li>
</ol>
<p>Experience: This use case has been implemented by multiple native smartphone apps with call-kit integration.</p>

</section>
<section id="videoconferencing*">
      <h3>Video Conferencing with a Central Server</h3>
      <p>[[?RFC7478]] Section 2.4.3.1 describes a use case involving Multiparty Video Communications with
      a central conferencing server. In such a use case, clients with disparate capabilities such as
      differing bandwidth availability,
      screen size and maximum displayable frame rate may participate in the same conference.
      In such a situation it is advantageous to support Scalable Video Coding (SVC).
      Encoding with temporal scalability is supported by several browsers today and is utilized by most
      centralized conferencing services.</p>
      <p>It is expected that spatial scalability (supported by VP9 and AV1) will become more popular with time.
      In this use case, if the desired video codec is known beforehand and participants are muted by default
      (as in a very large meeting), it is desirable to allow new participants to start receiving immediately,
      without negotiation. Supporting this enhancement adds the following requirements:</p>
  
<table class="simple">
    <thead>
       <tr>
          <th>Requirement ID</th>
          <th>Description</th>
       </tr>
    </thead>
    <tbody>
        <tr>
           <td>N06</td>
           <td>The user agent must be able to encode and decode
           video utilizing temporal scalability and (if supported
           by the chosen codec) spatial scalability.</td>
        </tr>
        <tr>
           <td>N07</td>
           <td>A user agent can receive audio/video without requiring
           construction of a corresponding sender object.</td>
        </tr>
        <tr>
           <td>N08</td>
           <td>It is possible to select the sending and/or
           receiving codec as well as rtcp parameters and
           header extensions without negotiation.</td>
        </tr>
        <tr>
           <td>N09</td>
           <td>The user agent must be able to control
           robustness (RTX, RED, FEC) applied to individual 
           simulcast and SVC layers.</td>
        </tr>
        <tr>
           <td>N24</td>
           <td>Content Security Policy (CSP) support for WebRTC.</td>
        </tr>
    </tbody>
</table>
  
<p>This use case has been implemented by conferencing services utilizing [[?ORTC]],
as well as proprietary additions to [[?WEBRTC]].</p>
</section>
</section>
<section id="newusecases*">
<h2>New Use Cases</h2>
<p>Several new uses cases relate to scenarios that cannot be supported in [[?WEBRTC]] without extensions.</p>
<section id="filesharing*">
<h3>File Sharing</h3>
<p>Participants in a mesh exchange large files without disruption to audio/video sessions.
It is also possible for a participant to send a large file to a user who is not currently online.
Supporting this use case adds the following requirements:</p>
  
<table class="simple">
    <thead>
       <tr>
          <th>Requirement ID</th>
          <th>Description</th>
       </tr>
    </thead>
    <tbody>
        <tr>
           <td>N10</td>
           <td>It must be possible for the user agent to initiate
           transfer of a large file with a single API operation.</td>
        </tr>
        <tr>
           <td>N11</td>
           <td>The application must be able to signal backpressure
           (flow control) when receiving data. It must also
           receive a backpressure signal when sending data.</td>
        </tr>
        <tr>
           <td>N12</td>
           <td>It must be possible for the user agent to transfer
           data utilizing a congestion control algorithm
           that does not compete aggressively with
           audio/video communications.</td>
        </tr>
        <tr>
           <td>N13</td>
           <td>It must be possible to support data exchange
           in a web, service, or shared worker. Support for 
           service workers allows the page to issue a fetch()
           which can be resolved in the service worker.</td>
        </tr>
        <tr>
           <td>N24</td>
           <td>Content Security Policy (CSP) support for WebRTC.</td>
        </tr>
    </tbody>
</table> 
<p>References:</p>
<ol>
  <li><a href="https://lists.w3.org/Archives/Public/public-webrtc/2018May/0079.html">Mailing list discussion</a></li>
  <li><a href="https://lists.w3.org/Archives/Public/public-webrtc/2018May/0082.html">Mailing list discussion</a></li>
</ol>
</section>
<section id="low-latency-streaming">
   <h3>Low latency streaming</h3>
<section id="game-streaming">
   <h4>Game streaming</h4>
   <p>Game streaming involves the sending of audio and video (potentially at high resolution and framerate)
   to the recipient, along with data being sent in the opposite direction. Games can be streamed either
   from a cloud service (client/server), or from a peer game console (P2P). It is highly desirable that
   media flow without interruption, and that game players not reveal their location to each other. Even in
   the case of games streamed from a cloud service, it can be desirable for players to be able to communicate
   with each other directly (via chat, audio or video).</p>
   <p class="note">This use case has not completed a Call for Consensus (CfC).</p>
<table class="simple">
    <thead>
       <tr>
          <th>Requirement ID</th>
          <th>Description</th>
       </tr>
    </thead>
    <tbody>
        <tr>
           <td>N15</td>
           <td>The application must be able to control aspects
           of the data transport  (e.g. set the SCTP
           heartbeat interval or turn it off), RTO values,
           etc.</td>
        </tr>
        <tr>
           <td>N36</td>
           <td>It must be possible for the user agent's receive pipeline to process
           video at high resolution and framerate (e.g. without copying raw video  
           frames).</td>  
        </tr>
        <tr>
           <td>N37</td>
           <td>The application must be able to control the jitter buffer and rendering
           delay.</td>
        </tr>
    </tbody>
</table>
<p>Experience: XCloud, Rainway, GeForce Now and Stadia are examples of this use case, with media
transported using WebRTC A/V or RTCDataChannel.</p>
</section> 
<section id="auction">
   <h4>Low latency Broadcast with Fanout</h4>
   <p>There are streaming applications that require large scale as well as low latency.
   Examples include sporting events, church services, webinars and company 'Town Hall' meetings.
   Live audio, video and data is sent to thousands (or even millions) of recipients.
   Limited interactivity may be supported, such as allowing authorized participants to ask
   questions at a company meeting. Both the media sender and receivers may be behind a NAT.
   P2P relays may be used to improve scalability, potentially using different transport than
   the original stream.</p>
    <p class="note">This use case has not completed a Call for Consensus (CfC).</p>
<table class="simple">
    <thead>
       <tr>
          <th>Requirement ID</th>
          <th>Description</th>
       </tr>
    </thead>
    <tbody>
        <tr>
           <td>N13</td>
           <td>It must be possible to support data exchange
           in a web, service, or shared worker. Support for 
           service workers allows the page to issue a fetch()
           which can be resolved in the service worker.</td>
        </tr>
        <tr>
           <td>N15</td>
           <td>The application must be able to control aspects
           of the data transport  (e.g. set the SCTP
           heartbeat interval or turn it off), RTO values,
           etc.</td>
        </tr>
        <tr>
           <td>N38</td>
           <td>A node must be able to forward media received from another node
           to a third node. Applications require access to encoded chunk metadata 
           as well as information from the RTP header to provide for timing, media
           configuration and congestion control. This includes a mechanism
           for a relaying peer to obtain a bandwidth estimate.</td>
        </tr>
    </tbody>
</table>
<p>Experience: |pipe|, Peer5 and Dolby are examples of this use case, with media
transported using WebRTC A/V or RTCDataChannel.</p>
</section>
</section>
<section id="iot*">
<h3>Internet of Things</h3>
<p>An IoT sensor maintains a long-term connection and seeks to minimize power consumption.
Some of the sensor’s data may need to be sent reliable and ordered while other sensors may
provide data that can be sent unreliable and unordered or in a partially reliable manner.
Such IoT sensors may also produce realtime video or audio data for remote users which are
privacy sensitive and may only be accessed by selected devices. This use case adds the
following requirements:</p>
  
<table class="simple">
    <thead>
       <tr>
          <th>Requirement ID</th>
          <th>Description</th>
       </tr>
    </thead>
    <tbody>
        <tr>
           <td>N14</td>
           <td>The application must be able to minimize ICE
           connectivity checks.</td>
        </tr>
        <tr>
           <td>N15</td>
           <td>The application must be able to control aspects
           of the data transport  (e.g. set the SCTP
           heartbeat interval or turn it off), RTO values,
           etc.</td>
        </tr>
        <tr>
           <td>N16</td>
           <td>It must be possible to send arbitrary data
           reliable, unreliable or partially reliable with
           a specific maximum number of retransmissions
           or a specific maximum timeout.</td>
        </tr>
        <tr>
           <td>N17</td>
           <td>It must be possible to send arbitrary data
           ordered or unordered.</td>
        </tr>
        <tr>
           <td>N24</td>
           <td>Content Security Policy (CSP) support for WebRTC.</td>
        </tr>
        <tr>
           <td>N33</td>
           <td>A pre-existing peers must be able to be (re) establish a connection
           without access to external services in the event of the local
           network becoming isolated from the wider network.  Without
           compromising e2e security but possibly leveraging pre-shared tokens from a previous connection.</td>
        </tr>
    </tbody>
</table>
<p>Reference</p>
<a href="https://lists.w3.org/Archives/Public/public-webrtc/2018May/0079.html">Mailing list discussion</a>
<p>Experience: Building a respiration monitor that works locally during an internet outage
but is also available remotely when the internet connection returns.</p>
</section>
<section id="decent">
   <h3>Decentralized messaging</h3>
   <p>New decentralized applications provide P2P services and client-server services for consumption in a browser.</p>
   <p>The differences in transport layer semantics make it difficult to share code between the two modes.</p>
   <p class="note">This use case has not completed a Call for Consensus (CfC).</p>
   <table class="simple">
       <thead>
          <tr>
             <th>Requirement ID</th>
             <th>Description</th>
          </tr>
       </thead>
       <tbody>
           <tr>
              <td>N34</td>
              <td>Ability to intercept the fetch API and service it over a P2P link.
              One way to do this would be to support data exchange in service workers 
              which can already intercept fetch.</td>
           </tr>
       </tbody>
   </table>  
   <p>Experience: Both |pipe| and [Matrix] have implemented systems of this sort.</p>
</section>
<section id="vr*">
<h3>Virtual Reality Gaming</h3>
<p>A virtual reality gaming service utilizing a centralized conferencing server wants
to synchronize data with media, using an existing Selective Forwarding Unit (SFU)
to distribute the data. This use case adds the following requirements:</p>
<table class="simple">
    <thead>
       <tr>
          <th>Requirement ID</th>
          <th>Description</th>
       </tr>
    </thead>
    <tbody>
        <tr>
           <td>N23</td>
           <td>The user agent must be able to send data synchronized
           with audio and video.</td>
        </tr>
        <tr>
           <td>N24</td>
           <td>Content Security Policy (CSP) support for WebRTC.</td>
        </tr>
    </tbody>
</table>  
<p>References:</p>
<a href="https://lists.w3.org/Archives/Public/public-webrtc/2018May/0063.html">Mailing list discussion</a>
</section>
<section id="funnyhats*">
<h3>Funny Hats</h3>
<p>A communications service that manipulates captured media prior to encoding and after
decoding to provide effects including:</p>
<ol>
  <li>Captioning</li>
  <li>Transcription</li>
  <li>Language translation</li>
  <li>Funny hats</li>
  <li>Background removal or blurring</li>
  <li>In-browser compositing</li>
  <li>Voice effects</li>
  <li>Stress detection</li>
</ol>
<p>This use case requires manipulation of raw media from both local and remote sources. Since
media processing can be CPU intensive, enabling it to occur off the main thread is important,
as is enabling the processing to take advantage of the GPU. This use case adds the following
requirements:</p>
    <p>This usecase also requires that user agent provide non-discriminatory implementations of
        facetracking and body tracking algorithms that can be efficiently used
        by the application. This however is outside the scope of this document.</p>
<table class="simple">
    <thead>
       <tr>
          <th>Requirement ID</th>
          <th>Description</th>
       </tr>
    </thead>
    <tbody>
        <tr>
           <td>N18</td>
           <td>The application must be able to obtain raw media
           from the capture device in desired formats.</td>
        </tr>
        <tr>
           <td>N19</td>
           <td>The application must be able to insert processed
           frames into the outgoing media path.</td>
        </tr>
        <tr>
           <td>N20</td>
           <td>The application must be able to obtain decoded
           media from the remote party.</td>
        </tr>
        <tr>
           <td>N21</td>
           <td>It must be possible to efficiently share media
           between the main thread and worker threads.</td>
        </tr>
        <tr>
           <td>N22</td>
           <td>It must be possible to do efficient media manipulation
           in worker threads by utilizing the GPU.</td>
        </tr>
        <tr>
           <td>N24</td>
           <td>Content Security Policy (CSP) support for WebRTC.</td>
        </tr>
    </tbody>
</table>
<p>References:</p>
<ol>
  <li><a href="https://lists.w3.org/Archives/Public/public-webrtc/2018May/0037.html">Mailing list discussion</a></li>
  <li><a href="https://lists.w3.org/Archives/Public/public-webrtc/2018Jun/0006.html">Mailing list discussion</a></li>
  <li><a href="https://ai.googleblog.com/2016/11/enhance-raisr-sharp-images-with-machine.html">Sharper Image Research</a></li>
</ol>
</section>
<section id="machinelearning*">
<h3>Machine Learning</h3>
<p>In a web game called “NameTheBird.com” participants use their devices to provide audio and video observations of
birds to the service along with identifications for training purposes, allowing the service to identify birds from
the provided audio and video and returning this information to the users in real-time.</p>
<p>The web application has a site specific federated learning-based classifier for contextual object detection,
user intent prediction and media manipulation, allowing it to augment the streams it receives and inject identifying
or other supplemental information into the streams sent or received.</p>
<p>The shared classification models are trained on the birds found by the participants and are based on the feedback
of the participants. Each device client updates of the model are up-streamed to a shared model server that pushes
updates of the global model to the clients.</p>
<p>Implementation outline:</p>
<ol>
  <li>Originating media (raw) streams are cloned for inference and training purposes, denoted “inference stream” and
  “training stream”, with the inference stream also being the media stream shared with peer(s). The cloning can occur
  any time during a session.</li>
  <li>Inference stream: A web site specific classifier acts on the raw inference stream, with the result used to
  guide a custom encoder in the sender device and send metadata to the server and peer devices outside the media stream.
  The encoder adds proper augmentation, e.g. sign with “name this bird” hovering over the enlarged bird in case of video
  enrichment, or enhanced bird song if audio.</li>
  <li>Training stream: Model in training classifies the raw data and evaluate the classification using user feedback,
  said feedback loop being web site specific. The evaluation may be  “online” or “offline”, offline meaning the training
  is done at a later stage on the recorded encoded media set.</li>
  <li>Both inference stream and training streams may use payload protection depending on trust model on compute
  resources for optional intermedia server side of app.</li>
  <li>Both inference stream and training streams use transport object for communicating with peers or servers,
  the communication in some cases can be a site specific QUIC based transport solution, in others RTP based.</li>
</ol>
<p>This use case adds the following requirements:</p>
<table class="simple">
    <thead>
       <tr>
          <th>Requirement ID</th>
          <th>Description</th>
       </tr>
    </thead>
    <tbody>
        <tr>
           <td>N18</td>
           <td>The application must be able to obtain raw media
           from the capture device in desired formats.</td>
        </tr>
        <tr>
           <td>N19</td>
           <td>The application must be able to insert processed
           frames into the outgoing media path.</td>
        </tr>
        <tr>
           <td>N20</td>
           <td>The application must be able to obtain decoded
           media from the remote party.</td>
        </tr>
        <tr>
           <td>N21</td>
           <td>It must be possible to efficiently share media
           between the main thread and worker threads.</td>
        </tr>
        <tr>
           <td>N22</td>
           <td>It must be possible to do efficient media
           manipulation in worker threads by utilizing the GPU.</td>
        </tr>
        <tr>
           <td>N24</td>
           <td>Content Security Policy (CSP) support for WebRTC.</td>
        </tr>
    </tbody>
</table>
</section>
<section id="no-trust-webex">
<h3>Don't Pown My Video Conferencing </h3>
<p>
  Cloud video conferencing systems have no need to be able to access
  the cleartext media and text flowing through their servers.
  Some of these conferencing services desire to be able to promote trust
  by explicitly showing they do not have access to contents of their
  users' calls. They are trusted to connect the right people to the
  conference and to route the packets but they are not trusted to access
  the audio and video media or text in the call.
</p>
<p>Solutions to this problem fall into two major categories: one where
  the JavaScript comes from a source trusted to see the media contents,
  and one where it does not.
</p>
<section id="untrusted*">
<h4>Untrusted JavaScript Cloud Conferencing</h4>
<p>
  There are many cases where a system such as WebEx is trusted to
  connect the members of a conference but has no need to access the
  contents of the conference. This is true of the majority of
  conferencing systems on the web today.  Just to highlight the
  scope of this requirement, there are more minutes of WebRTC
  that are used in conferences where the servers have no need
  to access the contents (e.g. where audio is forwarded rather than
  mixed) than any other use of WebRTC audio by orders of magnitude.
  This is one of the primary use case for WebRTC audio and accounts
  for billions of minutes per month of potential use of WebRTC.
 </p>
 <p>
  In this use case, the JavaScript comes from the operator of the
  conference bridge. The isolated media features of WebRTC can
  prevent the JavaScript from accessing the media and the identity
  features are used to provide a user interface that allows the
  user to know it connected to the correct conference. The goal is
  for the end users to be able to see the contents, but the web
  service that provides the JS and the media switching bridges
  and Selective Forwarding Units (SFUs) cannot access the contents
  (audio, video, text). The browser may choose to reveal some
  metadata, such as the audio power level, to the media server,
  in order to support functions like speaker switching.
</p>
<p>
   For small groups (fewer than 20 participants) the SFU could also
   run within the browser, further reducing the dependency on costly
   centralized servers with management functions running within a 
   web or service worker.
</p>
<p>
  A possible solution this problem is the browser to negotiate
  end-to-end encryption keys which are not revealed to the
  JavaScript.
</p>
<p>
  Security requirements relating to this use case are discussed
  in [[?MLS-ARCH]], and include the following:
</p>
  
  <table class="simple">
    <thead>
       <tr>
          <th>Requirement ID</th>
          <th>Description</th>
       </tr>
    </thead>
    <tbody>
        <tr>
          <td>N13</td>
          <td>It must be possible to support data exchange
           in a web, service, or shared worker. Support for 
           service workers allows the page to issue a fetch()
           which can be resolved in the service worker.</td>
        </tr>
        <tr>
           <td>N25</td>
           <td>Only current group members can receive media or
           text sent to the group.</td>
        </tr>
        <tr>
           <td>N26</td>
           <td>A group member cannot send media or text that
           appears to be from another group member.</td>
        </tr>
        <tr>
           <td>N27</td>
           <td>The conference server must not have access to
           cleartext media or text or to the identity of
           group members.</td>
        </tr>
        <tr>
           <td>N28</td>
           <td>Perfect Forward Secrecy (FCS): access to encrypted
           traffic as well as all current keying material does
           not compromise the secrecy of media or text older
           than the oldest key of a compromised client.</td>
        </tr>
        <tr>
           <td>N29</td>
           <td>Post Compromise Security (PCS). Protection against
           past or future device compromise.</td>
        </tr>
        <tr>
           <td>N35</td>
           <td>A group member can encrypt and send copies of the realtime encoded media directly
           to multiple group members without re-encoding for each recipient (to reduce resource usage).</td>
        </tr>
        <tr><td>note that the requirements from Machine Learning usecase are also required here.</td></tr>
    </tbody>
</table>
</section>
</section>
<section id="urisig">
   <h3>Reduced complexity signalling</h3>
   <p>Some simpler media/data sources/sinks require only a subset of WebRTC functionality.</p>
   <p>In such use cases the full SDP O/A could be replaced with a server generated token at runtime.</p>
   <p>A goal might be to set the source attribute of a video tag to point at a WebRTC video source.</p>
   <p>Care needs to be taken to avoid introducing security vulnerabilities.</p>
    <p class="note">This use case has not completed a Call for Consensus (CfC).</p>
   <table class="simple">
       <thead>
          <tr>
             <th>Requirement ID</th>
             <th>Description</th>
          </tr>
       </thead>
       <tbody>
           <tr>
              <td></td>
              <td>TBD</td>
           </tr>
       </tbody>
   </table>  
   <p>Experience: Both |pipe| and pion have built systems of this sort.</p>
</section>
<section id="live-encoded-media">
  <h3>Live encoded non-WebRTC media</h3>
  <p>
    There are use cases where it is desirable to transmit live
    encoded media from a non-WebRTC source over an RTP connection
    to a WebRTC-compatible endpoint. An example is traffic cameras
    that serve video over HTTP using "long poll" or similar mechanisms,
    but do not support WebRTC.
  </p>
  <p>
    The source may permit dynamic reconfiguration of its resolution or frame
    rate in order to produce an outgoing video stream with the desired
    characteristics.
  </p>
  <p class="note">This use case has not completed a Call for Consensus (CfC).</p>
   <table class="simple">
       <thead>
          <tr>
             <th>Requirement ID</th>
             <th>Description</th>
          </tr>
       </thead>
       <tbody>
        <tr>
           <td>N39</td>
           <td>An application can create an outgoing WebRTC connection without
           activating an encoder.</td>
        </tr>
        <tr>
           <td>N40</td>
           <td>An application can create encoded video frames from encoded data
           and metadata, and enqueue them on an outgoing WebRTC connection</td>
        </tr>
        <tr>
           <td>N41</td>
           <td>The WebRTC connection can generate signals indicating the desired
           bandwidth and any demands for keyframes, and surface those to the
           application.</td>
        </tr>
       </tbody>
   </table>  
</section>
<section id="stored-encoded-media">
  <h3>Transmitting stored encoded media</h3>
  <p>
    There are use cases with stored pre-encoded media where transmission as part of a
    WebRTC RTP session is desirable. These include:
    <ul>
      <li>
        "Wait signals" or "your message is important to us, please stay on the line", inserted
        prior to switching to a live interactive stream.
      </li>
      <li>
        Insertion of announcements or alarm signals in otherwise live streams.
      </li>
      <li>
        Insertion of static content (such as profile pictures) when the sender temporarily disables a camera.
      </li>
    </ul>
  </p>
  <p>
    The pre-encoded media may be available in multiple bandwidths, and switching between them may be
    possible at certain points in the media.
  </p>
    <p class="note">This use case has not completed a Call for Consensus (CfC).</p>
   <table class="simple">
       <thead>
          <tr>
             <th>Requirement ID</th>
             <th>Description</th>
          </tr>
       </thead>
       <tbody>
         <tr>
        <tr>
           <td>N40</td>
           <td>An application can create encoded video frames from encoded data
           and metadata, and enqueue them on an outgoing WebRTC connection</td>
        </tr>
        <tr>
           <td>N41</td>
           <td>The WebRTC connection can generate signals indicating the desired
           bandwidth and any demands for keyframes, and surface those to the
           application.</td>
        </tr>
        <tr>
           <td>N42</td>
           <td>The application can modify metadata on outgoing frames so that
           they fit smoothly within the expected sequence of timestamps and
           sequence numbers.</td>
        </tr>
        <tr>
           <td>N43</td>
           <td>The application can signal the WebRTC encoder when resuming live
           transmission in such a way that generated frames fit smoothly within
           the expected sequence of timestamps and sequence numbers.
           </td>
        </tr>
       </tbody>
   </table>
</section>
</section>
      
<section id="requirements*">
<h3>Requirements Summary</h3>
<p>This section summarizes the requirements arising from
the use-cases included in this document.</p>
<table class="simple">
    <thead>
       <tr>
          <th>Requirement ID</th>
          <th>Description</th>
       </tr>
    </thead>
    <tbody>
        <tr id="N01">
           <td>N01</td>
           <td>The user agent can control candidate gathering
           and pruning, limiting the networks on which candidates
           are gathered, the types of candidates, etc.</td>
        </tr>
        <tr id="N02">
           <td>N02</td>
           <td>The user agent must be capable of establishing multiple
           connections to peers without generating a separate
           configuration ("offer") for each connection prior to
           establishment.</td>
        </tr>
        <tr id="N03">
           <td>N03</td>
           <td>Congestion control must be able to manage audio
           quality and latency in a fair manner between multiple
           connections.</td>
        </tr>
           <tr id="N04">
           <td>N04</td>
           <td>The ICE agent must be able to maintain multiple
             candidate pairs and move traffic between them.</td>
        </tr>
        <tr id="N05">
           <td>N05</td>
           <td>The ICE agent must be able to take the network
           cost into account when considering re-routing.</td>
        </tr>
        <tr id="N06">
           <td>N06</td>
           <td>The user agent must be able to encode and decode
           video utilizing temporal scalability and (if supported
           by the chosen codec) spatial scalability.</td>
        </tr>
        <tr id="N07">
           <td>N07</td>
           <td>A user agent can receive audio/video without requiring
           construction of a corresponding sender object.</td>
        </tr>
        <tr id="N08">
           <td>N08</td>
           <td>It is possible to select the sending and/or
           receiving codec as well as rtcp parameters and
           header extensions without negotiation.</td>
        </tr>
        <tr id="N09">
           <td>N09</td>
           <td>The user agent must be able to control
           robustness (RTX, RED, FEC) applied to individual 
           simulcast and SVC layers.</td>
        </tr>
        <tr id="N10">
           <td>N10</td>
           <td>It must be possible for the user agent to initiate
           transfer of a large file with a single API operation.</td>
        </tr>
        <tr id="N11">
           <td>N11</td>
           <td>The application must be able to signal backpressure
           (flow control) when receiving data. It must also
           receive a backpressure signal when sending data.</td>
        </tr>
        <tr id="N12">
           <td>N12</td>
           <td>It must be possible for the user agent to transfer
           data utilizing a congestion control algorithm
           that does not compete aggressively with
           audio/video communications.</td>
        </tr>
        <tr id="N13">
           <td>N13</td>
           <td>It must be possible to support data exchange
           in a web, service, or shared worker. Support for 
           service workers allows the page to issue a fetch()
           which can be resolved in the service worker.</td>
        </tr>
        <tr id="N14">
           <td>N14</td>
           <td>The application must be able to minimize ICE
           connectivity checks.</td>
        </tr>
        <tr id="N15">
           <td>N15</td>
           <td>The application must be able to control aspects
           of the data transport  (e.g. set the SCTP
           heartbeat interval or turn it off), RTO values,
           etc.</td>
        </tr>
        <tr id="N16">
           <td>N16</td>
           <td>It must be possible to send arbitrary data
           reliable, unreliable or partially reliable with
           a specific maximum number of retransmissions
           or a specific maximum timeout.</td>
        </tr>
        <tr id="N17">
           <td>N17</td>
           <td>It must be possible to send arbitrary data
           ordered or unordered.</td>
        </tr>
        <tr id="N18">
           <td>N18</td>
           <td>The application must be able to obtain raw media
           from the capture device in desired formats.</td>
        </tr>
        <tr id="N19">
           <td>N19</td>
           <td>The application must be able to insert processed
           frames into the outgoing media path.</td>
        </tr>
        <tr id="N20">
           <td>N20</td>
           <td>The application must be able to obtain decoded
           media from the remote party.</td>
        </tr>
        <tr id="N21">
           <td>N21</td>
           <td>It must be possible to efficiently share media
           between the main thread and worker threads.</td>
        </tr>
        <tr id="N22">
           <td>N22</td>
           <td>It must be possible to do efficient media
           manipulation in worker threads by utilizing the GPU.</td>
        </tr>
        <tr id="N23">
           <td>N23</td>
           <td>The user agent must be able to send data synchronized
           with audio and video.</td>
        </tr>
        <tr id="N24">
           <td>N24</td>
           <td>Content Security Policy (CSP) support for WebRTC.</td>
        </tr>
        <tr id="N25">
           <td>N25</td>
           <td>Only current group members can receive media or
           text sent to the group.</td>
        </tr>
        <tr id="N26">
           <td>N26</td>
           <td>A group member cannot send media or text that
           appears to be from another group member.</td>
        </tr>
        <tr id="N27">
           <td>N27</td>
           <td>The conference server must not have access to
           cleartext media or text or to the identity of
           group members.</td>
        </tr>
        <tr id="N28">
           <td>N28</td>
           <td>Perfect Forward Secrecy (FCS): access to encrypted
           traffic as well as all current keying material does
           not compromise the secrecy of media or text older
           than the oldest key of a compromised client.</td>
        </tr>
        <tr id="N29">
           <td>N29</td>
           <td>Post Compromise Security (PCS). Protection against
           past or future device compromise.</td>
        </tr>
        </tr id="N30">
           <td>N30</td>
           <td>The user agent must provide the ability to re-establish
           media after an interruption.</td>
        </tr>
        </tr id="N31">
           <td>N31</td>
        <td>The user agent must provide notification of a media interruption caused by the OS (e.g. GSM incoming call) (c.f. on hold music).
            and support the use of a datachannel to inform the remote peer of the interruption.</td>
        </tr>
        </tr id="N32">
           <td>N32</td>
           <td>The user agent must provide the ability to 'park' a connection such
           that it can be retrieved and continued by a newly loaded page to prevent
           accidental 'browsing away' from dropping a call irretrievably.</td>
        </tr id="N33">
           <td>N33</td>
           <td>Pre-existing peers must be able to be (re-)establish a connection
            without access to external services in the event of the local
            network becoming isolated from the wider network.  Without
            compromising e2e security but possibly leveraging pre-shared tokens from a previous connection.</td>
        </tr>
        </tr id="N34">
           <td>N34</td>
           <td>Ability to intercept the fetch API and service it over a P2P link.
           One way to do this would be to support data channels in Service Workers 
           which can already intercept fetch.</td>
        </tr>
        </tr id="N35">
           <td>N35</td>
        <td>A group member can encrypt and send copies of the realtime encoded media directly
            to multiple group members without re-encoding for each recipient (to reduce resource usage).</td>
        </tr>
        <tr id="N36">
           <td>N36</td>
           <td>It must be possible for the user agent's receive pipeline to process
           video at high resolution and framerate (e.g. without copying raw video
           frames).</td>                   
        </tr>
        <tr id="N37">
           <td>N37</td>
           <td>The application must be able to control the jitter buffer and rendering
           delay.</td>
        </tr>
        <tr id="N38">
           <td>N38</td>
           <td>A node must be able to forward media received from another node
           to a third node. Applications require access to encoded chunk metadata 
           as well as information from the RTP header to provide for timing, media
           configuration and congestion control. This includes a mechanism
           for a relaying peer to obtain a bandwidth estimate.</td>
        </tr>
        <tr id="N39">
           <td>N39</td>
           <td>An application can create an outgoing WebRTC connection without
           activating an encoder.</td>
        </tr>
        <tr id="N40">
           <td>N40</td>
           <td>An application can create encoded video frames from encoded data
           and metadata, and enqueue them on an outgoing WebRTC connection</td>
        </tr>
        <tr id="N41">
           <td>N41</td>
           <td>The WebRTC connection can generate signals indicating the desired
           bandwidth and any demands for keyframes, and surface those to the
           application.</td>
        </tr>
        <tr id="N42">
           <td>N42</td>
           <td>The application can modify metadata on outgoing frames so that
           they fit smoothly within the expected sequence of timestamps and
           sequence numbers.</td>
        </tr>
        <tr id="N43">
           <td>N43</td>
           <td>The application can signal the WebRTC encoder when resuming live
           transmission in such a way that generated frames fit smoothly within
           the expected sequence of timestamps and sequence numbers.
           </td>
        </tr>
    </tbody>
</table>
<p class="note">Requirements N30-N43 have not completed a Call for Consensus (CfC).</p>
</section>
</body>
</html>
